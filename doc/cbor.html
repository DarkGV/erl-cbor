<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Module cbor</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module cbor</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>The cbor module is an implementation of the CBOR data encoding format
  as defined by RFC 7049.

<p><b>References</b><ul><li>See <a href="https://tools.ietf.org/html/rfc7049">RFC 7049</a>.</li></ul></p>

<h2><a name="description">Description</a></h2>The cbor module is an implementation of the CBOR data encoding format
  as defined by RFC 7049.
 
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-decoding_options">decoding_options()</a></h3>
<p><tt>decoding_options() = #{tagged_value_interpreters =&gt; #{<a href="#type-tag">tag()</a> := <a href="#type-tagged_value_interpreter">tagged_value_interpreter()</a>}}</tt></p>
<p>  A set of options affecting CBOR decoding:
  <dl>
    <dt><code>tagged_value_interpreters</code></dt>
    <dd>
      A map containing a tagged value interpreter function for each supported
      tagged value. Unsupported tagged values will be decoded to a tuple of
      the form <code>{Tag, Value}</code>.
    </dd>
  </dl></p>

<h3 class="typedecl"><a name="type-decoding_result">decoding_result()</a></h3>
<p><tt>decoding_result(ValueType) = {ok, ValueType, iodata()} | {error, term()}</tt></p>
<p>  The type of values returned by decoding functions.</p>

<h3 class="typedecl"><a name="type-float_value">float_value()</a></h3>
<p><tt>float_value() = float() | positive_infinity | negative_infinity | nan</tt></p>
<p>  A floating point type extending the standard <code>float/0</code> type to support
  IEEE.754 special values. Note that we do not include a value for negative
  zero since Erlang accepts the <code>-0</code> syntax but considers it equal to <code>0`; we
  could add a `negative_zero</code> value, but it would be inconsistent compared to
  the handling of positive zero.</p>

<h3 class="typedecl"><a name="type-interpretation_result">interpretation_result()</a></h3>
<p><tt>interpretation_result(ValueType) = {ok, ValueType} | {error, term()}</tt></p>
<p>  The type of values returned by interpretation functions.</p>

<h3 class="typedecl"><a name="type-simple_value">simple_value()</a></h3>
<p><tt>simple_value() = {simple_value, 0..255} | false | true | null | undefined</tt></p>
<p>  A simple CBOR value as defined in RFC 7049 2.3.</p>

<h3 class="typedecl"><a name="type-tag">tag()</a></h3>
<p><tt>tag() = non_neg_integer()</tt></p>
<p>  A semantic tag as defined in RFC 7049 2.4.</p>

<h3 class="typedecl"><a name="type-tagged_value">tagged_value()</a></h3>
<p><tt>tagged_value() = {<a href="#type-tag">tag()</a>, term()}</tt></p>
<p>  A CBOR tagged value, i.e. a value with an integer tag acting like a
  semantic hint.</p>

<h3 class="typedecl"><a name="type-tagged_value_interpreter">tagged_value_interpreter()</a></h3>
<p><tt>tagged_value_interpreter() = fun((<a href="#type-tagged_value">tagged_value()</a>) -&gt; <a href="#type-interpretation_result">interpretation_result</a>(term()))</tt></p>
<p>  A function used to interpret a CBOR tagged value.</p>

<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#decode-1">decode/1</a></td><td>Decode a CBOR value from binary data and return both the Erlang value
  it represents and the rest of the binary data which were not decoded.</td></tr>
<tr><td valign="top"><a href="#decode-2">decode/2</a></td><td>Decode a CBOR value from binary data and return both the Erlang value  
it represents and the rest of the binary data which were not decoded.</td></tr>
<tr><td valign="top"><a href="#decode_hex-1">decode_hex/1</a></td><td>Decode a CBOR value from an hex-encoded string and return both the
  Erlang value it represents and the rest of the string which was not
  decoded.</td></tr>
<tr><td valign="top"><a href="#decode_hex-2">decode_hex/2</a></td><td>Decode a CBOR value from an hex-encoded string and return both the
  Erlang value it represents and the rest of the string which was not
  decoded.</td></tr>
<tr><td valign="top"><a href="#default_decoding_options-0">default_decoding_options/0</a></td><td>Return the default list of decoding options.</td></tr>
<tr><td valign="top"><a href="#default_tagged_value_interpreters-0">default_tagged_value_interpreters/0</a></td><td>Return the default map of tagged value interpreters.</td></tr>
<tr><td valign="top"><a href="#encode-1">encode/1</a></td><td>Encode an Erlang value and return the binary representation of the  
resulting CBOR value.</td></tr>
<tr><td valign="top"><a href="#encode_hex-1">encode_hex/1</a></td><td>Encode an Erlang value and return the representation of the resulting
  CBOR value as an hex-encoded string.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="decode-1">decode/1</a></h3>
<div class="spec">
<p><tt>decode(Data::iodata()) -&gt; <a href="#type-decoding_result">decoding_result</a>(term())</tt><br></p>
</div><p>Decode a CBOR value from binary data and return both the Erlang value
  it represents and the rest of the binary data which were not decoded.
 </p>
<p><b>See also:</b> <a href="#decode-2">decode/2</a>.</p>

<h3 class="function"><a name="decode-2">decode/2</a></h3>
<div class="spec">
<p><tt>decode(X1::iodata(), Opts::<a href="#type-decoding_options">decoding_options()</a>) -&gt; {ok, term(), iodata()} | {error, term()}</tt><br></p>
</div><p><p>Decode a CBOR value from binary data and return both the Erlang value  
it represents and the rest of the binary data which were not decoded.</p>
 
  CBOR values are converted to Erlang values as follows:
  <ul>
    <li>
      CBOR integers, unsigned integers, and negative integers are converted
      to Erlang integers.
    </li>
    <li>
      CBOR byte strings are converted to Erlang binaries.
    </li>
    <li>
      CBOR UTF-8 strings are validated and converted to Erlang binaries.
    </li>
    <li>
      CBOR arrays are converted to Erlang lists.
    </li>
    <li>
      CBOR maps are converted to Erlang maps.
    </li>
    <li>
      CBOR tagged values are converted either to tuples of the form <code>{Tag,
      Value}</code> or, for specific tags, to the following Erlang values:
      <dl>
       <dt>0 (standard datetime)</dt>
       <dd>
         A RFC3339-formatted binary string.
       </dd>
       <dt>1 (epoch-based datetime)</dt>
       <dd>
         A nanosecond epoch-based timestamp.
       </dd>
       <dt>2 (positive bignum)</dt>
       <dt>3 (negative bignum)</dt>
       <dd>
         An Erlang integer.
       </dd>
       <dt>24 (CBOR data)</dt>
       <dd>
         An Erlang value formed by decoding the CBOR-encoded byte string.
       </dd>
       <dt>32 (URI)</dt>
       <dd>
         An Erlang binary string containing the URI. While it would be
         possible to parse the URI string, using for example the <code>uri_string</code>
         module, it would not be practical since most functions using URIs
         expect the textual representation.
       </dd>
       <dt>33 (base64url-encoded data)</dt>
       <dd>
         An Erlang binary formed by decoding the base64url-encoded UTF-8
         string.
       </dd>
       <dt>34 (base64-encoded data)</dt>
       <dd>
         An Erlang binary formed by decoding the base64-encoded UTF-8 string.
       </dd>
       <dt>35 (regular expression)</dt>
       <dd>
         An Erlang binary string containing the regular expression.
       </dd>
       <dt>36 (MIME message)</dt>
       <dd>
         An Erlang binary string containing the MIME message.
       </dd>
       <dt>55799 (CBOR value)</dt>
       <dd>
         An Erlang value formed by decoding the tagged value.
       </dd>
      </dl>
      We do not interpret:
      <ul>
        <li>
          decimal fractions and big floats, because Erlang do not have data
          types to store them;
        </li>
        <li>
          expected encoding to base64url, base64 and base16 (tags 21 to 23)
          because the resulting encoded data would be ambiguous.
        </li>
      </ul>
    </li>
    <li>
      CBOR simple values are converted either to tuples of the form
      <code>{simple_value, Integer}</code> or, for specific numeric values, to the
      following Erlang values:
      <dl>
       <dt>20</dt><dd><code>false</code></dd>
       <dt>21</dt><dd><code>true</code></dd>
       <dt>22</dt><dd><code>null</code></dd>
       <dt>23</dt><dd><code>undefined</code></dd>
      </dl>
    </li>
    <li>
      CBOR floats are converted to Erlang floats. NaN is converted to the
      <code>nan</code> atom. Positive and negative infinity values are converted
      respectively to the <code>positive_infinity</code> and <code>negative_infinity</code> atoms.
    </li>
  </ul></p>

<h3 class="function"><a name="decode_hex-1">decode_hex/1</a></h3>
<div class="spec">
<p><tt>decode_hex(Value::string()) -&gt; <a href="#type-decoding_result">decoding_result</a>(term())</tt><br></p>
</div><p>Decode a CBOR value from an hex-encoded string and return both the
  Erlang value it represents and the rest of the string which was not
  decoded.
 </p>
<p><b>See also:</b> <a href="#decode-1">decode/1</a>.</p>

<h3 class="function"><a name="decode_hex-2">decode_hex/2</a></h3>
<div class="spec">
<p><tt>decode_hex(Str::string(), Opts::<a href="#type-decoding_options">decoding_options()</a>) -&gt; <a href="#type-decoding_result">decoding_result</a>(term())</tt><br></p>
</div><p>Decode a CBOR value from an hex-encoded string and return both the
  Erlang value it represents and the rest of the string which was not
  decoded.
 </p>
<p><b>See also:</b> <a href="#decode-2">decode/2</a>.</p>

<h3 class="function"><a name="default_decoding_options-0">default_decoding_options/0</a></h3>
<div class="spec">
<p><tt>default_decoding_options() -&gt; <a href="#type-decoding_options">decoding_options()</a></tt><br></p>
</div><p>Return the default list of decoding options.</p>

<h3 class="function"><a name="default_tagged_value_interpreters-0">default_tagged_value_interpreters/0</a></h3>
<div class="spec">
<p><tt>default_tagged_value_interpreters() -&gt; #{<a href="#type-tag">tag()</a> := <a href="#type-tagged_value_interpreter">tagged_value_interpreter()</a>}</tt><br></p>
</div><p>Return the default map of tagged value interpreters.</p>

<h3 class="function"><a name="encode-1">encode/1</a></h3>
<div class="spec">
<p><tt>encode(Value::term()) -&gt; iodata()</tt><br></p>
</div><p><p>Encode an Erlang value and return the binary representation of the  
resulting CBOR value.</p>
 
  <p>Integers, floats, boolean, binaries, lists and maps are encoded to the  
associated CBOR type.</p>
 
  Atoms are used for specific constants:
  <dl>
    <dt><code>positive_infinity</code></dt>
    <dd>IEEE.754 positive infinity.</dd>
 
    <dt><code>negative_infinity</code></dt>
    <dd>IEEE.754 negative infinity.</dd>
 
    <dt><code>nan</code></dt>
    <dd>IEEE.754 NaN.</dd>
 
    <dt><code>null</code></dt>
    <dd>CBOR null value.</dd>
 
    <dt><code>undefined</code></dt>
    <dd>CBOR undefined value.</dd>
  </dl>
 
  Tuples are used for more complex CBOR values:
  <dl>
    <dt><code>{string, Value}</code></dt>
    <dd>
      <code>Value</code> is encoded to a CBOR string; <code>Value</code> must be of type
      <code>unicode:chardata/0</code>.
    </dd>
    <dt><code>{datetime, Value}</code></dt>
    <dt><code>{datetime, Value, UTCOffset}</code></dt>
    <dd>
      <code>Value</code> is encoded to a CBOR text string tagged as a standard datetime
      string. <code>Value</code> must be of type <code>cbor_time:datetime/0</code>. If present,
      <code>UTCOffset</code> is used to transform the universal date represented by
      <code>Value</code> into a local date whose timezone is separated from Universal
      Coordinated Time (UTC) by <code>UTCOffset</code> seconds.
    </dd>
    <dt><code>{timestamp, Value}</code></dt>
    <dd>
      <code>Value</code> is encoded to a CBOR integer or floating point number tagged as
      an epoch-based datetime. <code>Value</code> must be either of type
      <code>cbor_time:datetime/0</code> or of type <code>erlang:timestamp()</code>.
    </dd>
    <dt><code>{Tag, Value}</code></dt>
    <dd>
      <code>Value</code> is encoded to a tagged CBOR value. <code>Tag</code> must be a positive
      integer.
    </dd>
  </dl></p>

<h3 class="function"><a name="encode_hex-1">encode_hex/1</a></h3>
<div class="spec">
<p><tt>encode_hex(Value::term()) -&gt; <a href="unicode.html#type-chardata">unicode:chardata()</a></tt><br></p>
</div><p>Encode an Erlang value and return the representation of the resulting
  CBOR value as an hex-encoded string.
 </p>
<p><b>See also:</b> <a href="#encode-1">encode/1</a>.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc</i></p>
</body>
</html>
